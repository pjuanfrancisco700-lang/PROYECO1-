<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Nave de Cuaderno</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background:
        repeating-linear-gradient(
          to bottom,
          #fdfbf6,
          #fdfbf6 22px,
          #d7e3ff 23px
        ); /* hoja rayada */
      color: #222;
      display: flex;
      justify-content: center;
      align-items: stretch;
      min-height: 100vh;
    }

    .app {
      width: 100%;
      max-width: 480px;
      margin: 0 auto;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .card {
      background: rgba(255, 255, 255, 0.85);
      border: 1.5px solid #444;
      box-shadow: 0 0 0 1px #00000020;
      border-radius: 8px;
      padding: 10px;
    }

    .title {
      font-family: "Comic Sans MS", system-ui, sans-serif;
      font-size: 1.4rem;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin: 0 0 4px;
    }

    .subtitle {
      font-size: 0.8rem;
      text-align: center;
      opacity: 0.7;
      margin-bottom: 8px;
    }

    label {
      font-size: 0.8rem;
      display: block;
      margin-bottom: 2px;
    }

    input[type="text"] {
      width: 100%;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid #888;
      font-size: 0.9rem;
      outline: none;
      background: #fff;
    }

    .row {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-top: 6px;
      flex-wrap: wrap;
    }

    button {
      flex: 1;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1.5px solid #222;
      background: #fff;
      font-size: 0.9rem;
      font-weight: 600;
      box-shadow: 1px 1px 0 #00000060;
      cursor: pointer;
    }

    button:active {
      transform: translate(1px, 1px);
      box-shadow: 0 0 0 #000;
    }

    .status-bar {
      display: flex;
      justify-content: space-between;
      font-size: 0.85rem;
      margin-top: 4px;
    }

    .status-label {
      font-weight: 600;
    }

    .game-wrapper {
      flex: 1;
      min-height: 280px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    #gameCanvas {
      width: 100%;
      height: auto;
      background: rgba(255, 255, 255, 0.9);
      border: 1.5px solid #333;
      border-radius: 12px;
      box-shadow: 2px 2px 0 #00000040;
      touch-action: none;
    }

    .controls {
      display: flex;
      gap: 8px;
      margin-top: 6px;
    }

    .controls button {
      font-size: 1.1rem;
      padding: 10px 0;
    }

    .ranking {
      max-height: 150px;
      overflow-y: auto;
      margin-top: 4px;
      font-size: 0.85rem;
    }

    .ranking-item {
      display: flex;
      justify-content: space-between;
      padding: 3px 0;
      border-bottom: 1px dashed #ccc;
    }

    .game-over-banner {
      position: absolute;
      inset: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      pointer-events: none;
    }

    .game-over-text {
      background: #fff8e1;
      border: 2px solid #222;
      padding: 8px 12px;
      border-radius: 10px;
      font-size: 1rem;
      font-weight: 700;
      box-shadow: 2px 2px 0 #00000070;
    }

    @media (max-height: 600px) {
      .game-wrapper {
        min-height: 220px;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <!-- Panel superior: nombre y botones -->
    <div class="card">
      <h1 class="title">Nave de Cuaderno</h1>
      <div class="subtitle">Pega solo a los cÃ­rculos, evita las lÃ­neas.</div>
      <label for="playerName">Tu nombre (para el ranking):</label>
      <input id="playerName" type="text" placeholder="Ej. Sergio, Darwi, etc." />
      <div class="row">
        <button id="btnUseName">Usar nombre</button>
        <button id="btnShowRanking">Ver ranking</button>
      </div>
      <div class="status-bar">
        <div><span class="status-label">Jugador:</span> <span id="currentPlayer">â€”</span></div>
        <div><span class="status-label">Mejor puntaje:</span> <span id="bestScore">0</span></div>
      </div>
    </div>

    <!-- Juego -->
    <div class="game-wrapper card" style="position: relative;">
      <canvas id="gameCanvas"></canvas>
      <div class="status-bar">
        <div><span class="status-label">Puntaje:</span> <span id="score">0</span></div>
        <div><span class="status-label">Estado:</span> <span id="gameStateText">Listo</span></div>
      </div>
      <div class="controls">
        <button id="btnLeft">â¬…ï¸Ž</button>
        <button id="btnShoot">ðŸ”«</button>
        <button id="btnRight">âž¡ï¸Ž</button>
      </div>
      <div class="game-over-banner" id="gameOverBanner" style="display:none;">
        <div class="game-over-text" id="gameOverText">Game Over</div>
      </div>
    </div>

    <!-- Ranking -->
    <div class="card">
      <div class="status-label" style="margin-bottom:4px;">Ranking (mejores puntajes en este dispositivo)</div>
      <div id="rankingList" class="ranking"></div>
    </div>
  </div>

  <script>
    // ---------- UTILIDADES DE RANKING ----------
    const STORAGE_KEY = "naveCuadernoRanking";

    function loadRanking() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return [];
        return JSON.parse(raw);
      } catch (e) {
        return [];
      }
    }

    function saveRanking(ranking) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(ranking));
    }

    function addScoreToRanking(name, score) {
      if (!name) return;
      const ranking = loadRanking();
      ranking.push({
        name,
        score,
        date: new Date().toISOString()
      });
      ranking.sort((a, b) => b.score - a.score);
      // dejamos solo top 20
      saveRanking(ranking.slice(0, 20));
    }

    function renderRanking() {
      const rankingDiv = document.getElementById("rankingList");
      const ranking = loadRanking();
      rankingDiv.innerHTML = "";
      if (!ranking.length) {
        rankingDiv.textContent = "Sin puntajes aÃºn. Juega una partida para guardar tu score.";
        return;
      }
      ranking.forEach((item, index) => {
        const row = document.createElement("div");
        row.className = "ranking-item";
        const nameSpan = document.createElement("span");
        nameSpan.textContent = `${index + 1}. ${item.name}`;
        const scoreSpan = document.createElement("span");
        scoreSpan.textContent = item.score;
        row.appendChild(nameSpan);
        row.appendChild(scoreSpan);
        rankingDiv.appendChild(row);
      });
    }

    function updateBestScoreLabel(currentPlayer) {
      const ranking = loadRanking();
      let best = 0;
      if (currentPlayer) {
        // mejor puntaje de ese jugador
        const forPlayer = ranking.filter(r => r.name === currentPlayer);
        if (forPlayer.length) {
          best = Math.max(...forPlayer.map(r => r.score));
        }
      } else if (ranking.length) {
        best = Math.max(...ranking.map(r => r.score));
      }
      document.getElementById("bestScore").textContent = best;
    }

    // ---------- LOGICA DEL JUEGO ----------
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    let devicePixelRatio = window.devicePixelRatio || 1;

    function resizeCanvas() {
      const rectWidth = canvas.clientWidth || canvas.parentElement.clientWidth || 300;
      const rectHeight = Math.min(window.innerHeight * 0.45, 420);

      canvas.width = rectWidth * devicePixelRatio;
      canvas.height = rectHeight * devicePixelRatio;
      ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
    }

    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);

    // Estado del juego
    let ship = {
      x: 0,
      y: 0,
      width: 40,
      height: 22,
      speed: 4
    };

    let bullets = [];
    let objects = []; // cÃ­rculos y lÃ­neas
    let lastSpawn = 0;
    let spawnInterval = 800; // ms
    let lastTime = 0;
    let score = 0;
    let running = false;
    let gameOver = false;
    let currentPlayer = "";

    const scoreLabel = document.getElementById("score");
    const stateLabel = document.getElementById("gameStateText");
    const gameOverBanner = document.getElementById("gameOverBanner");
    const gameOverText = document.getElementById("gameOverText");

    function resetGame() {
      resizeCanvas();
      ship.x = canvas.width / devicePixelRatio / 2;
      ship.y = canvas.height / devicePixelRatio - 35;
      bullets = [];
      objects = [];
      lastSpawn = 0;
      score = 0;
      scoreLabel.textContent = score;
      gameOver = false;
      running = true;
      stateLabel.textContent = "Jugando";
      gameOverBanner.style.display = "none";
      lastTime = performance.now();
      requestAnimationFrame(loop);
    }

    function spawnObject() {
      const isCircle = Math.random() < 0.65; // 65% cÃ­rculos
      const x = 20 + Math.random() * ((canvas.width / devicePixelRatio) - 40);
      const y = -20;
      if (isCircle) {
        objects.push({
          type: "circle",
          x,
          y,
          radius: 10 + Math.random() * 8,
          speed: 1.4 + Math.random() * 0.6
        });
      } else {
        // lÃ­nea vertical
        objects.push({
          type: "line",
          x,
          y,
          length: 32 + Math.random() * 12,
          speed: 1.2 + Math.random() * 0.5
        });
      }
    }

    function update(dt) {
      // mover nave en los lÃ­mites
      const halfW = ship.width / 2;
      if (ship.x < halfW) ship.x = halfW;
      if (ship.x > canvas.width / devicePixelRatio - halfW) {
        ship.x = canvas.width / devicePixelRatio - halfW;
      }

      // actualizar balas
      bullets.forEach(b => {
        b.y -= b.speed * dt;
      });
      bullets = bullets.filter(b => b.y > -10);

      // actualizar objetos
      objects.forEach(o => {
        o.y += o.speed * dt;
      });
      objects = objects.filter(o => o.y < canvas.height / devicePixelRatio + 40);

      // colisiones balas - objetos
      bullets.forEach(bullet => {
        objects.forEach(obj => {
          if (obj._hit) return;

          if (obj.type === "circle") {
            const dx = bullet.x - obj.x;
            const dy = bullet.y - obj.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist <= obj.radius + 4) {
              obj._hit = true;
              bullet._hit = true;
              score++;
              scoreLabel.textContent = score;
            }
          } else if (obj.type === "line") {
            // lÃ­nea vertical: chequeo simple
            const lineTop = obj.y;
            const lineBottom = obj.y + obj.length;
            const dx = Math.abs(bullet.x - obj.x);
            if (dx < 4 && bullet.y >= lineTop && bullet.y <= lineBottom) {
              // golpeÃ³ una lÃ­nea â†’ game over
              obj._hit = true;
              bullet._hit = true;
              endGame("Le pegaste a una lÃ­nea ðŸ˜µ");
            }
          }
        });
      });

      bullets = bullets.filter(b => !b._hit);
      objects = objects.filter(o => !o._hit);

      // colisiÃ³n nave - lÃ­neas (si chocan)
      objects.forEach(obj => {
        if (obj.type === "line") {
          const lineTop = obj.y;
          const lineBottom = obj.y + obj.length;
          const withinX = Math.abs(ship.x - obj.x) < ship.width * 0.6;
          const withinY = lineBottom >= ship.y - ship.height / 2 && lineTop <= ship.y + ship.height / 2;
          if (withinX && withinY) {
            endGame("Una lÃ­nea golpeÃ³ tu nave ðŸ˜µ");
          }
        }
      });
    }

    function drawShip() {
      const x = ship.x;
      const y = ship.y;
      const w = ship.width;
      const h = ship.height;

      ctx.save();
      ctx.translate(x, y);

      ctx.strokeStyle = "#222";
      ctx.lineWidth = 1.6;
      ctx.lineJoin = "round";

      ctx.beginPath();
      ctx.moveTo(-w / 2, h / 2);
      ctx.lineTo(0, -h / 2);
      ctx.lineTo(w / 2, h / 2);
      ctx.closePath();
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(-w / 4, h / 2);
      ctx.lineTo(-w / 6, h / 2 + 6);
      ctx.moveTo(w / 4, h / 2);
      ctx.lineTo(w / 6, h / 2 + 6);
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(0, 0, 3.5, 0, Math.PI * 2);
      ctx.stroke();

      ctx.restore();
    }

    function drawObjects() {
      ctx.strokeStyle = "#222";
      ctx.lineWidth = 1.3;

      objects.forEach(obj => {
        if (obj.type === "circle") {
          ctx.beginPath();
          ctx.arc(obj.x, obj.y, obj.radius, 0, Math.PI * 2);
          ctx.stroke();
        } else {
          ctx.beginPath();
          ctx.moveTo(obj.x, obj.y);
          ctx.lineTo(obj.x, obj.y + obj.length);
          ctx.stroke();
        }
      });
    }

    function drawBullets() {
      ctx.strokeStyle = "#222";
      ctx.lineWidth = 1.4;
      bullets.forEach(b => {
        ctx.beginPath();
        ctx.moveTo(b.x, b.y);
        ctx.lineTo(b.x, b.y + 6);
        ctx.stroke();
      });
    }

    function clearCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function loop(timestamp) {
      if (!running) return;
      const dtMs = timestamp - lastTime;
      lastTime = timestamp;
      const dt = dtMs / 16.67; // normalizado a ~60 FPS

      lastSpawn += dtMs;
      if (lastSpawn > spawnInterval) {
        lastSpawn = 0;
        spawnObject();
      }

      update(dt);

      clearCanvas();
      drawObjects();
      drawBullets();
      drawShip();

      if (!gameOver) {
        requestAnimationFrame(loop);
      }
    }

    function endGame(reason) {
      if (gameOver) return;
      gameOver = true;
      running = false;
      stateLabel.textContent = "Terminado";
      gameOverText.textContent = `${reason}\nPuntaje: ${score}`;
      gameOverBanner.style.display = "flex";

      if (currentPlayer) {
        addScoreToRanking(currentPlayer, score);
        renderRanking();
        updateBestScoreLabel(currentPlayer);
      }

      // Reinicio suave despuÃ©s de unos segundos
      setTimeout(() => {
        gameOverBanner.style.display = "none";
        stateLabel.textContent = "Listo";
      }, 2500);
    }

    // ---------- CONTROLES ----------
    function moveLeft() {
      ship.x -= ship.speed * 4;
    }

    function moveRight() {
      ship.x += ship.speed * 4;
    }

    function shoot() {
      if (!running || gameOver) {
        // si el juego no estÃ¡ corriendo, empezar una nueva partida
        resetGame();
        return;
      }
      bullets.push({
        x: ship.x,
        y: ship.y - ship.height / 2,
        speed: 4.2
      });
    }

    document.getElementById("btnLeft").addEventListener("click", moveLeft);
    document.getElementById("btnRight").addEventListener("click", moveRight);
    document.getElementById("btnShoot").addEventListener("click", shoot);

    // Tocar/arrastrar sobre el canvas para mover la nave
    let dragging = false;
    canvas.addEventListener("pointerdown", (e) => {
      dragging = true;
    });
    canvas.addEventListener("pointerup", () => {
      dragging = false;
    });
    canvas.addEventListener("pointermove", (e) => {
      if (!dragging) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      ship.x = x;
    });

    // Tap rÃ¡pido en la parte baja del canvas dispara
    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const y = e.clientY - rect.top;
      if (y > rect.height * 0.65) {
        shoot();
      }
    });

    // ---------- MANEJO DE JUGADOR Y RANKING ----------
    const playerNameInput = document.getElementById("playerName");
    const currentPlayerLabel = document.getElementById("currentPlayer");
    const btnUseName = document.getElementById("btnUseName");
    const btnShowRanking = document.getElementById("btnShowRanking");

    btnUseName.addEventListener("click", () => {
      const name = playerNameInput.value.trim();
      if (!name) {
        alert("Escribe un nombre para poder guardar tus puntajes.");
        return;
      }
      currentPlayer = name;
      currentPlayerLabel.textContent = currentPlayer;
      updateBestScoreLabel(currentPlayer);
    });

    btnShowRanking.addEventListener("click", () => {
      renderRanking();
    });

    // Inicial
    renderRanking();
    updateBestScoreLabel("");
  </script>
</body>
</html>
